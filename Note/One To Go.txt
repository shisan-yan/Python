															Python笔记<One To Go>

Add By 2017-09-06

1. 变量
	1.1 局部变量
	1.2 全局变量
	
2. 函数
	2.1 不定长函数
	function(a,b,*args):    		ab后面所有的参数都会以元组的方式存在args中
	function(a,b,c,*args,**kargs) 
		这样在调用的时候，前三个参数分别给a,b,c,带变量名的给kargs，不带变量名的给args
		function(11,22,33,task=88,done=99)
3. 拆包
	def test(a,b,c=33,*args,**kwargs):
		print a
		print b
		print c
		print args
		print kwargs
	A = (44,55,55)
	B = {"name":"laowang","age":"20"}

	test(11,22,33,*A,**B)  这样传入的A跟B前的*表示的就是拆包，表示将A跟B里面的元素拆分赋值；如果要拆分一个元组就用一个*如果拆分一个字典就用两个*

4. 引用
	A = 100
	B = A

	print B   此时打出100

	A = 200

	print B  此时打出的还是100，也就是B = A 这个赋值语句只是将B也指向了A指向的那个变量值的内存地址，相当于变量值的内存地址有了两个指向，当A做其他的指向或者改变的时候并不影响B
	
5. 可变与不可变类型
	可变：列表、字典
	不可变：数字、字符串、元组

6. 递归
	就算阶乘
	def getNum(num=4):
		if num >1:
			return num * getNum(num-1)
		else:
			return num 

7. 匿名函数
	infors = [{'name':'yang','age':'20'},{'name':'jack','age':'30'}]

	infors.sorts(key=lambda x:x['age'])

	匿名函数的调用


8. 文件相关
	r   读取文件，文件不存在报错
	w   写文件，文件不存在则新建
	rb  以二进制的方式读取文件，不存在报错
	wb  以二进制的方式写文件，不存在则新建
	r+  以读写的方式创建文件，文件不存在报错
	w+  以读写的方式创建文件，文件不存在则创建

	f = open('filename','model')

	f.read()   #每次读取一次
	f.write()  #写入文件内容，文件内容中的\n代表换行  f.write('\n haha ')
	f.close()  #关闭操作文件的句柄

	8.1 实现文件的复制 


	8.2 大文件的处理方式
		每次读取的时候读取固定大小
		当读取的长度为0时结束程序
		f = open('file.txt','r')
		content = f.read(1024)
		if len(content) == 0:
			break
	8.3 定位读写（seek）
		f = open('test.py')
		f.seek(2,0)     2表示偏移量，0标示文件的开头，1表示当前位置，2表示文件末尾
		f.readline()    这样就是偏移两个单位后进行去读文件的内容

	8.4 文件的相关操作
		通过借助OS库，可以实现文件的删除、创建、重命名、复制、移动

	8.5 批量出重命名

9. 面向对象
	9.1 类和对象

	类的组成
		类的名称：类名
		类的属性：一组数据
		类的方法：允许对进行操作的方法(行为)

	类的抽象

	类的定义
		class 类名:
			#属性
			#方法

	调用对象的方法
		def Cat:
			#属性
			#方法
			def eat(self):
				print 'eat'

			def drink(self):
				print 'drink'
		#创建一个对象
		obj = Cat()
		tom.eat()
		tom.drink()

	给对象添加属性
		tom = Cat()
		tom.name = 'tomejason'
		tom.age = 2


	创建多个对象

	self
		class Cat:
			def eat(self):
				print 'this is the %s'%(self.name)


		tom =  Cat()
		tom.name = 'tom'
		tom.eat()

		tim =  Cat()
		tim.name = 'tim'
		tim.eat()

		#这样我们就能通过self形参的方式，实现哪个对象调用我们就采用哪个对象的值的结果
	
	self的注意点
		定义函数内的方法的时候，尽量要养成添加一个形参的习惯，否则在多种情况调用的时候会出现混乱

	__init__
		class Cat:

			#初始化对象
			def __init__(self):
				#将需要初始化的数据放到这里

	__str__

	











